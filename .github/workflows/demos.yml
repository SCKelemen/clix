name: Generate Demo GIFs

on:
  push:
    branches:
      - main
    paths:
      - 'examples/**'
      - 'demos/vhs/generate-demos.sh'
      - '.github/workflows/demos.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'examples/**'
      - 'demos/vhs/generate-demos.sh'
  workflow_dispatch:
    inputs:
      force_regenerate:
        description: 'Force regenerate all GIFs'
        required: false
        default: false
        type: boolean

# Prevent multiple runs from committing at the same time
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      tapes: ${{ steps.tapes.outputs.tapes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      
      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
      
      - name: Find all tape files
        id: tapes
        run: |
          # Find all tape files and output as JSON array for matrix
          TAPES=$(find examples -name "*.tape" -type f | jq -R -s -c 'split("\n") | map(select(. != ""))')
          echo "tapes=$TAPES" >> $GITHUB_OUTPUT
          echo "Found tape files:"
          find examples -name "*.tape" -type f

  setup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache-dependency-path: go.sum
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg ttyd xvfb zsh
      
      - name: Cache VHS binary
        id: cache-vhs
        uses: actions/cache@v4
        with:
          path: ${{ env.GOPATH }}/bin
          key: vhs-${{ runner.os }}-${{ hashFiles('go.sum') }}
          restore-keys: |
            vhs-${{ runner.os }}-
      
      - name: Install VHS
        if: steps.cache-vhs.outputs.cache-hit != 'true'
        run: |
          mkdir -p $HOME/go/bin
          go install github.com/charmbracelet/vhs@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

  generate-demos:
    needs: [prepare, setup]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        tape: ${{ fromJson(needs.prepare.outputs.tapes) }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.PERSONAL_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          ref: ${{ github.ref }}
          fetch-depth: 0
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Restore VHS from cache
        id: cache-vhs
        uses: actions/cache@v4
        with:
          path: ${{ env.GOPATH }}/bin
          key: vhs-${{ runner.os }}-${{ hashFiles('go.sum') }}
          restore-keys: |
            vhs-${{ runner.os }}-
      
      - name: Install VHS if not cached
        if: steps.cache-vhs.outputs.cache-hit != 'true'
        run: |
          mkdir -p $HOME/go/bin
          go install github.com/charmbracelet/vhs@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg ttyd xvfb zsh
      
      - name: Build example
        run: |
          TAPE_FILE="${{ matrix.tape }}"
          # Use bash parameter expansion for case-sensitive path handling
          EXAMPLE_DIR="${TAPE_FILE%/*}"
          EXAMPLE_NAME="${EXAMPLE_DIR##*/}"
          
          echo "Building example: $EXAMPLE_NAME in $EXAMPLE_DIR"
          echo "Tape file: $TAPE_FILE"
          
          # Verify paths exist (case-sensitive check)
          if [ ! -d "$EXAMPLE_DIR" ]; then
            echo "ERROR: Example directory not found: $EXAMPLE_DIR"
            exit 1
          fi
          
          # Build the example
          if [ -d "$EXAMPLE_DIR/cmd" ]; then
            for cmd_dir in "$EXAMPLE_DIR/cmd"/*/; do
              if [ -d "$cmd_dir" ] && [ -f "$cmd_dir/main.go" ]; then
                cmd_name=$(basename "$cmd_dir")
                binary_name="$EXAMPLE_NAME"
                
                # Special cases
                case "$EXAMPLE_NAME" in
                  "basic") binary_name="demo" ;;
                  "survey") binary_name="demo" ;;
                  "lipgloss") binary_name="styled" ;;
                esac
                
                echo "Building $cmd_name -> $binary_name"
                (cd "$EXAMPLE_DIR" && go build -o "$binary_name" "./cmd/$cmd_name" || true)
              fi
            done
          else
            echo "WARNING: cmd directory not found in $EXAMPLE_DIR"
          fi
          
          # Handle multicli separately
          if [ "$EXAMPLE_NAME" = "multicli" ] && [ -d "$EXAMPLE_DIR/cmd" ]; then
            cd "$EXAMPLE_DIR" || exit 1
            for cmd_dir in cmd/*/; do
              if [ -d "$cmd_dir" ] && [ -f "$cmd_dir/main.go" ]; then
                binary=$(basename "$cmd_dir")
                echo "Building multicli/$binary"
                go build -o "$binary" "./$cmd_dir" || true
              fi
            done
          fi
      
      - name: Discover and generate tape file
        run: |
          cd demos/vhs
          chmod +x generate-demos.sh
          GENERATE_GIFS=0 ./generate-demos.sh
      
      - name: Setup display server
        run: |
          export DISPLAY=:99
          Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
          sleep 2
      
      - name: Generate demo GIF
        timeout-minutes: 10
        run: |
          export DISPLAY=:99
          export PATH="/usr/bin:/bin:/usr/local/bin:$HOME/go/bin:$PATH"
          TAPE_FILE="${{ matrix.tape }}"
          # Use bash parameter expansion instead of dirname/basename
          EXAMPLE_DIR="${TAPE_FILE%/*}"
          TAPE_NAME="${TAPE_FILE##*/}"
          
          # Ensure we're in the example directory (case-sensitive)
          if [ ! -d "$EXAMPLE_DIR" ]; then
            echo "ERROR: Example directory not found: $EXAMPLE_DIR"
            exit 1
          fi
          cd "$EXAMPLE_DIR" || exit 1
          echo "Working directory: $(pwd)"
          echo "Go version: $(go version)"
          echo "Go path: $(which go)"
          echo "VHS path: $(which vhs)"
          echo "Contents before VHS:"
          ls -la
          
          # Update tape file to use actual PATH (VHS doesn't expand variables in Env)
          # Replace $HOME and $PATH with actual values
          GO_BIN_PATH="$HOME/go/bin"
          ACTUAL_PATH="/usr/bin:/bin:/usr/local/bin:$GO_BIN_PATH:$(echo $PATH | tr ':' '\n' | grep -v "^$GO_BIN_PATH$" | tr '\n' ':' | sed 's/:$//')"
          # On Linux, sed -i requires a backup suffix; on macOS, empty string works
          # Try Linux style first (with .bak), then macOS style (empty string)
          if grep -q "Env PATH" "$TAPE_NAME"; then
            if sed -i.bak "s|Env PATH \".*\"|Env PATH \"$ACTUAL_PATH\"|" "$TAPE_NAME" 2>/dev/null || \
               sed -i '' "s|Env PATH \".*\"|Env PATH \"$ACTUAL_PATH\"|" "$TAPE_NAME" 2>/dev/null; then
              # Remove backup file if created
              rm -f "${TAPE_NAME}.bak"
              echo "Updated PATH in tape file:"
              grep "Env PATH" "$TAPE_NAME"
            else
              echo "Warning: Could not update PATH in tape file, continuing anyway..."
            fi
          else
            echo "No Env PATH directive found in tape file (may not be needed)"
          fi
          
          echo "Generating GIF from $TAPE_FILE"
          # VHS needs Go in PATH for the build commands in tape files
          # Set environment variables that VHS will use for color support
          export TERM=xterm-256color
          export COLORTERM=truecolor
          unset NO_COLOR  # Ensure NO_COLOR is not set
          timeout 600 vhs < "$TAPE_NAME" || {
            echo "VHS failed or timed out, checking for errors..."
            echo "Contents after VHS:"
            ls -la
            echo "Checking if binary exists:"
            find . -name "*.gif" -o -name "styled" -o -name "demo" -o -name "gcloud" -o -name "gh" | head -10
            exit 1
          }
          
          # Upload generated GIF as artifact
          GIF_FILE="${TAPE_NAME%.tape}.gif"
          if [ -f "$GIF_FILE" ]; then
            echo "GIF generated: $GIF_FILE ($(ls -lh "$GIF_FILE" | awk '{print $5}'))"
            mkdir -p "$GITHUB_WORKSPACE/gifs"
            cp "$GIF_FILE" "$GITHUB_WORKSPACE/gifs/"
          else
            echo "ERROR: GIF file not found: $GIF_FILE"
            echo "Available files:"
            ls -la
            exit 1
          fi
        env:
          DISPLAY: :99
          TERM: xterm-256color
          COLORTERM: truecolor
          NO_COLOR: ""  # Explicitly unset NO_COLOR
          PATH: /usr/bin:/bin:/usr/local/bin:${{ env.PATH }}:$HOME/go/bin
      
      - name: Upload generated GIF
        if: always()
        run: |
          # Sanitize artifact name (replace / with - and remove examples- prefix)
          TAPE_FILE="${{ matrix.tape }}"
          ARTIFACT_NAME=$(echo "$TAPE_FILE" | sed 's/\//-/g' | sed 's/^examples-/gif-/' | sed 's/\.tape$//')
          echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
          echo "Artifact name: $ARTIFACT_NAME"
      
      - name: Upload generated GIF artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: gifs/*.gif
          retention-days: 1

  commit:
    needs: generate-demos
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.PERSONAL_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          ref: ${{ github.ref }}
          fetch-depth: 0
      
      - name: Download all generated GIFs
        uses: actions/download-artifact@v4
        with:
          pattern: gif-*
          merge-multiple: true
          path: gifs
      
      - name: Copy GIFs to example directories
        run: |
          echo "Downloaded GIFs location:"
          find gifs -name "*.gif" -type f || echo "No GIFs found in gifs directory"
          echo ""
          echo "Current example directories:"
          ls -la examples/*/ | head -20
          echo ""
          
          # Copy each downloaded GIF to its corresponding example directory
          for gif_file in gifs/*.gif; do
            if [ -f "$gif_file" ]; then
              gif_name=$(basename "$gif_file")
              echo "Processing $gif_name"
              
              # Find matching example directory by checking tape files
              for example_dir in examples/*/; do
                for tape_file in "$example_dir"/*.tape; do
                  if [ -f "$tape_file" ]; then
                    expected_gif="${tape_file%.tape}.gif"
                    if [ "$(basename "$expected_gif")" = "$gif_name" ]; then
                      echo "Copying $gif_file to $example_dir"
                      cp "$gif_file" "$example_dir/"
                      echo "Copied! Verifying:"
                      ls -lh "$example_dir/$gif_name"
                      break 2
                    fi
                  fi
                done
              done
            fi
          done
          
          echo ""
          echo "GIFs after copying:"
          find examples -name "*.gif" -type f
      
      - name: Check for changes
        id: check
        run: |
          if [ -n "$(git status --porcelain examples/*/*.gif examples/*/*.tape)" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Changed files:"
            git status --porcelain examples/*/*.gif examples/*/*.tape
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Commit changes
        if: steps.check.outputs.changed == 'true'
        run: |
          # Get the branch name - use HEAD_REF for PRs, otherwise extract from GITHUB_REF
          if [ -n "${{ github.head_ref }}" ]; then
            BRANCH_NAME="${{ github.head_ref }}"
          else
            BRANCH_NAME=${GITHUB_REF#refs/heads/}
          fi
          
          # Fetch latest changes to avoid conflicts
          git fetch origin "$BRANCH_NAME" || true
          
          # Checkout the branch if we're in detached HEAD state
          git checkout -B "$BRANCH_NAME" "origin/$BRANCH_NAME" 2>/dev/null || git checkout "$BRANCH_NAME"
          
          # Pull latest changes to ensure we're up to date
          git pull origin "$BRANCH_NAME" --rebase || git pull origin "$BRANCH_NAME" || true
          
          git config --local user.email "${{ secrets.GIT_USER_EMAIL || 'SCKelemen@users.noreply.github.com' }}"
          git config --local user.name "${{ secrets.GIT_USER_NAME || 'Samuel Kelemen' }}"
          
          # Re-check for changes after pulling (another run might have already committed)
          if [ -n "$(git status --porcelain examples/*/*.gif examples/*/*.tape)" ]; then
            git add examples/*/*.gif examples/*/*.tape
            git commit -m "Auto-update demo GIFs [skip ci]" || exit 0
            
            # Retry push with rebase if there's a conflict
            git pull origin "$BRANCH_NAME" --rebase || true
            git push origin "$BRANCH_NAME" || {
              echo "Push failed, trying with rebase..."
              git pull origin "$BRANCH_NAME" --rebase
              git push origin "$BRANCH_NAME" || exit 0
            }
          else
            echo "No changes to commit (likely already committed by another run)"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
